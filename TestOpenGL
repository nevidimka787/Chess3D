/*#define BLACK_KING			-1
#define BLACK_SUPER_QUIN		-2
#define	BLACK_QUIN_DIAGONAL		-3
#define BLACK_QUIN				-4
#define BLACK_BISHOP_DIAGONAL	-5
#define BLACK_BISHOP			-6
#define BLACK_KNIGHT_DIAGONAL	-7
#define BLACK_KNIGHT			-8
#define BLACK_ROOK				-9
#define BLACK_PAWN				-10
#define VOID					 0
#define WHITE_KING				 1
#define WHITE_SUPER_QUIN		 2
#define	WHITE_QUIN_DIAGONAL		 3
#define WHITE_QUIN				 4
#define WHITE_BISHOP_DIAGONAL	 5
#define WHITE_BISHOP			 6
#define WHITE_KNIGHT_DIAGONAL	 7
#define WHITE_KNIGHT			 8
#define WHITE_ROOK				 9
#define WHITE_PAWN				 10
#define WHITE					 true
#define BLACK					 false*/

#include <iostream>
#include<string>
#include "List.h"
#include "List.cpp"
#include "GameSpace.h"
#include "GameSpace.cpp"
#include <GL/glut.h>

double test_angle = 0;

List* list = new List(1);
GameSpace* gamespase1 = new GameSpace(*list);

const int BLACK_KING = -1, BLACK_SUPER_QUIN = -2, BLACK_QUIN_DIAGONAL = -3, BLACK_QUIN = -4, BLACK_BISHOP_DIAGONAL = -5, BLACK_BISHOP = -6, BLACK_KNIGHT_DIAGONAL = -7, BLACK_KNIGHT = -8, BLACK_ROOK = -9, BLACK_PAWN = -10, _VOID = 0, WHITE_KING = 1, WHITE_SUPER_QUIN = 2, WHITE_QUIN_DIAGONAL = 3, WHITE_QUIN = 4, WHITE_BISHOP_DIAGONAL = 5, WHITE_BISHOP = 6, WHITE_KNIGHT_DIAGONAL = 7, WHITE_KNIGHT = 8, WHITE_ROOK = 9, WHITE_PAWN = 10;

const bool WHITE = true, BLACK = false;

int window_wight = 1000, window_hight = 800;

int window_x_left_up_position = 400, window_y_left_up_position = 400;

short move_x = 0, move_y = 0, move_z = 0;//возможность перемещения по оси -1 - REVERS; 0 - STOP; 1 - FORVARD

float red = 1.0f, blue = 1.0f, green = 1.0f, alpha = 0.1f;

double angle_xz = -3.86, angle_xy = -0.55, d_angle_xz = 0, d_angle_xy = 0;// угол поворота камеры

float mouse_x_position_last = NULL, mouse_y_position_last = NULL;// значение предыдущей позиции мыши

float lx = sin(angle_xz) * cos(angle_xy), ly = sin(angle_xy), lz = -cos(angle_xz) * cos(angle_xy);// координаты вектора направления движения камеры

float dx = 0.0f, dy = 0.0f, dz = 0.0f;// смещения по осям

float x = -20.0f, y = 49.0f, z = -20.0f;// начальная позиция камеры

float camera_speed = 0.2f, mouse_modification = 0.001f;// скорость 

bool forvard_backvard = true;

bool show_lines = false;

bool bottoms[100];
bool mouse_motion = false;


void draw_cube(double x_position, double y_position, double z_position, double rang)
{
	glBegin(GL_TRIANGLES);

	glColor4f(0.9f, 0.6f, 0.3f, 0.5f);

	glVertex3f(x_position + rang, y_position + rang, z_position + rang);
	glVertex3f(x_position - rang, y_position + rang, z_position + rang);
	glVertex3f(x_position + rang, y_position - rang, z_position + rang);

	glVertex3f(x_position - rang, y_position + rang, z_position + rang);
	glVertex3f(x_position + rang, y_position - rang, z_position + rang);
	glVertex3f(x_position - rang, y_position - rang, z_position + rang);

	glColor4f(0.9f, 0.3f, 0.6f, 0.5f);

	glVertex3f(x_position + rang, y_position + rang, z_position - rang);
	glVertex3f(x_position - rang, y_position + rang, z_position - rang);
	glVertex3f(x_position + rang, y_position - rang, z_position - rang);

	glVertex3f(x_position - rang, y_position + rang, z_position - rang);
	glVertex3f(x_position + rang, y_position - rang, z_position - rang);
	glVertex3f(x_position - rang, y_position - rang, z_position - rang);

	glColor4f(0.6f, 0.9f, 0.3f, 0.5f);

	glVertex3f(x_position + rang, y_position + rang, z_position + rang);
	glVertex3f(x_position - rang, y_position + rang, z_position + rang);
	glVertex3f(x_position + rang, y_position + rang, z_position - rang);

	glVertex3f(x_position - rang, y_position + rang, z_position + rang);
	glVertex3f(x_position + rang, y_position + rang, z_position - rang);
	glVertex3f(x_position - rang, y_position + rang, z_position - rang);

	glColor4f(0.6f, 0.3f, 0.9f, 0.5f);

	glVertex3f(x_position + rang, y_position - rang, z_position + rang);
	glVertex3f(x_position - rang, y_position - rang, z_position + rang);
	glVertex3f(x_position + rang, y_position - rang, z_position - rang);

	glVertex3f(x_position - rang, y_position - rang, z_position + rang);
	glVertex3f(x_position + rang, y_position - rang, z_position - rang);
	glVertex3f(x_position - rang, y_position - rang, z_position - rang);

	glColor4f(0.3f, 0.9f, 0.6f, 0.5f);

	glVertex3f(x_position + rang, y_position + rang, z_position + rang);
	glVertex3f(x_position + rang, y_position - rang, z_position + rang);
	glVertex3f(x_position + rang, y_position + rang, z_position - rang);

	glVertex3f(x_position + rang, y_position - rang, z_position + rang);
	glVertex3f(x_position + rang, y_position + rang, z_position - rang);
	glVertex3f(x_position + rang, y_position - rang, z_position - rang);

	glColor4f(0.3f, 0.6f, 0.9f, 0.5f);

	glVertex3f(x_position - rang, y_position + rang, z_position + rang);
	glVertex3f(x_position - rang, y_position - rang, z_position + rang);
	glVertex3f(x_position - rang, y_position + rang, z_position - rang);

	glVertex3f(x_position - rang, y_position - rang, z_position + rang);
	glVertex3f(x_position - rang, y_position + rang, z_position - rang);
	glVertex3f(x_position - rang, y_position - rang, z_position - rang);
	glEnd();
}

void draw_cube()
{
	glutSolidCube(1.0f);
}

void draw_king(bool white, float figure_size)
{
	glBegin(GL_TRIANGLES);
	glEnd();
	draw_cube(0, 0, 0, 1);
}

void draw_super_quin(bool white, float figure_size)
{
	if (white)
	{
		glColor3f(0.9f, 0.9f, 0.9f);
	}
	else
	{
		glColor3f(0.1f, 0.1f, 0.1f);
	}
	glBegin(GL_TRIANGLES);
	glEnd();
	draw_cube(0, 0, 0, 1);
}

void draw_quin_diagonal(bool white, float figure_size)
{
	if (white)
	{
		glColor3f(0.9f, 0.9f, 0.9f);
	}
	else
	{
		glColor3f(0.1f, 0.1f, 0.1f);
	}
	glBegin(GL_TRIANGLES);
	glEnd();
	draw_cube(0, 0, 0, 1);
}

void draw_quin(bool white, float figure_size)
{
	if (white)
	{
		glColor3f(0.9f, 0.9f, 0.9f);
	}
	else
	{
		glColor3f(0.1f, 0.1f, 0.1f);
	}
	glBegin(GL_TRIANGLES);
	glEnd();
	draw_cube(0, 0, 0, 1);
}

void draw_bishop_diagonal(bool white, float figure_size)
{
	if (white)
	{
		glColor3f(0.9f, 0.9f, 0.9f);
	}
	else
	{
		glColor3f(0.1f, 0.1f, 0.1f);
	}
	glBegin(GL_TRIANGLES);
	glEnd();
	draw_cube(0, 0, 0, 1);
}

void draw_bishop(bool white, float figure_size)
{
	if (white)
	{
		glColor3f(0.9f, 0.9f, 0.9f);
	}
	else
	{
		glColor3f(0.1f, 0.1f, 0.1f);
	}
	glBegin(GL_TRIANGLES);
	glEnd();
	draw_cube(0, 0, 0, 1);
}

void draw_knight_diagonal(bool white, float figure_size)
{
	if (white)
	{
		glColor3f(0.9f, 0.9f, 0.9f);
	}
	else
	{
		glColor3f(0.1f, 0.1f, 0.1f);
	}
	glBegin(GL_TRIANGLES);
	glEnd();
	draw_cube(0, 0, 0, 1);
}

void draw_knight(bool white, float figure_size)
{
	if (white)
	{
		glColor3f(0.9f, 0.9f, 0.9f);
	}
	else
	{
		glColor3f(0.1f, 0.1f, 0.1f);
	}
	glBegin(GL_TRIANGLES);
	glEnd();
	draw_cube(0, 0, 0, 1);
}

void draw_rook(bool white, float figure_size)
{
	const double scale = 4;
	if (white)
	{
		glColor3f(0.8f, 0.8f, 0.8f);
	}
	else
	{
		glColor3f(0.2f, 0.2f, 0.2f);
	}

	glPushMatrix();
	glTranslatef(0.0, 0.0, 0.0);
	glRotatef(0.0, 0.0, 0.0, 0.0);
	glBegin(GL_TRIANGLES);

	glVertex3f(figure_size, scale * figure_size, 0);
	glVertex3f(figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);
	glVertex3f(-figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);

	glVertex3f(figure_size, scale * figure_size, 0);
	glVertex3f(-figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);
	glVertex3f(-figure_size, scale * figure_size, 0);

	glVertex3f(figure_size, scale * figure_size, 0);
	glVertex3f(-figure_size, scale * figure_size, 0);
	glVertex3f(-figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);

	glVertex3f(figure_size, scale * figure_size, 0);
	glVertex3f(-figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);


	glVertex3f(figure_size, scale * figure_size, 0);
	glVertex3f(figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);
	glVertex3f(figure_size, -scale * figure_size, 0);

	glVertex3f(figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);
	glVertex3f(figure_size, -scale * figure_size, 0);
	glVertex3f(figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);

	glVertex3f(figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);
	glVertex3f(-figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);
	glVertex3f(figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);

	glVertex3f(-figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);
	glVertex3f(figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);

	glVertex3f(-figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);
	glVertex3f(-figure_size, scale * figure_size, 0);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);

	glVertex3f(-figure_size, scale * figure_size, 0);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);
	glVertex3f(-figure_size, -scale * figure_size, 0);

	glVertex3f(-figure_size, scale * figure_size, 0);
	glVertex3f(-figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(-figure_size, -scale * figure_size, 0);

	glVertex3f(-figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(-figure_size, -scale * figure_size, 0);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);

	glVertex3f(-figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);

	glVertex3f(figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);

	glVertex3f(figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(figure_size, scale * figure_size, 0);
	glVertex3f(figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);

	glVertex3f(figure_size, scale * figure_size, 0);
	glVertex3f(figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(figure_size, -scale * figure_size, 0);


	glVertex3f(figure_size, -scale * figure_size, 0);
	glVertex3f(figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);

	glVertex3f(figure_size, -scale * figure_size, 0);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);
	glVertex3f(-figure_size, -scale * figure_size, 0);

	glVertex3f(figure_size, -scale * figure_size, 0);
	glVertex3f(-figure_size, -scale * figure_size, 0);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);

	glVertex3f(figure_size, -scale * figure_size, 0);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);

	glEnd();
	glPopMatrix();

	glPushMatrix();
	glTranslatef(0.0, 0.0, 0.0);
	glRotatef(90.0, 1.0, 0.0, 0.0);
	glBegin(GL_TRIANGLES);

	glVertex3f(figure_size, scale * figure_size, 0);
	glVertex3f(figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);
	glVertex3f(-figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);

	glVertex3f(figure_size, scale * figure_size, 0);
	glVertex3f(-figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);
	glVertex3f(-figure_size, scale * figure_size, 0);

	glVertex3f(figure_size, scale * figure_size, 0);
	glVertex3f(-figure_size, scale * figure_size, 0);
	glVertex3f(-figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);

	glVertex3f(figure_size, scale * figure_size, 0);
	glVertex3f(-figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);


	glVertex3f(figure_size, scale * figure_size, 0);
	glVertex3f(figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);
	glVertex3f(figure_size, -scale * figure_size, 0);

	glVertex3f(figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);
	glVertex3f(figure_size, -scale * figure_size, 0);
	glVertex3f(figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);

	glVertex3f(figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);
	glVertex3f(-figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);
	glVertex3f(figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);

	glVertex3f(-figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);
	glVertex3f(figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);

	glVertex3f(-figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);
	glVertex3f(-figure_size, scale * figure_size, 0);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);

	glVertex3f(-figure_size, scale * figure_size, 0);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);
	glVertex3f(-figure_size, -scale * figure_size, 0);

	glVertex3f(-figure_size, scale * figure_size, 0);
	glVertex3f(-figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(-figure_size, -scale * figure_size, 0);

	glVertex3f(-figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(-figure_size, -scale * figure_size, 0);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);

	glVertex3f(-figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);

	glVertex3f(figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);

	glVertex3f(figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(figure_size, scale * figure_size, 0);
	glVertex3f(figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);

	glVertex3f(figure_size, scale * figure_size, 0);
	glVertex3f(figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(figure_size, -scale * figure_size, 0);


	glVertex3f(figure_size, -scale * figure_size, 0);
	glVertex3f(figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);

	glVertex3f(figure_size, -scale * figure_size, 0);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);
	glVertex3f(-figure_size, -scale * figure_size, 0);

	glVertex3f(figure_size, -scale * figure_size, 0);
	glVertex3f(-figure_size, -scale * figure_size, 0);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);

	glVertex3f(figure_size, -scale * figure_size, 0);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);

	glEnd();
	glPopMatrix();

	glPushMatrix();
	glTranslatef(0.0, 0.0, 0.0);
	glRotatef(90.0, 0.0, 0.0, 1.0);
	glBegin(GL_TRIANGLES);

	glVertex3f(figure_size, scale* figure_size, 0);
	glVertex3f(figure_size * 0.5, scale* figure_size, figure_size* sqrt(3) / 2);
	glVertex3f(-figure_size * 0.5, scale* figure_size, figure_size* sqrt(3) / 2);

	glVertex3f(figure_size, scale* figure_size, 0);
	glVertex3f(-figure_size * 0.5, scale* figure_size, figure_size* sqrt(3) / 2);
	glVertex3f(-figure_size, scale* figure_size, 0);

	glVertex3f(figure_size, scale* figure_size, 0);
	glVertex3f(-figure_size, scale* figure_size, 0);
	glVertex3f(-figure_size * 0.5, scale* figure_size, -figure_size * sqrt(3) / 2);

	glVertex3f(figure_size, scale* figure_size, 0);
	glVertex3f(-figure_size * 0.5, scale* figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(figure_size * 0.5, scale* figure_size, -figure_size * sqrt(3) / 2);


	glVertex3f(figure_size, scale* figure_size, 0);
	glVertex3f(figure_size * 0.5, scale* figure_size, figure_size* sqrt(3) / 2);
	glVertex3f(figure_size, -scale * figure_size, 0);

	glVertex3f(figure_size * 0.5, scale* figure_size, figure_size* sqrt(3) / 2);
	glVertex3f(figure_size, -scale * figure_size, 0);
	glVertex3f(figure_size * 0.5, -scale * figure_size, figure_size* sqrt(3) / 2);

	glVertex3f(figure_size * 0.5, scale* figure_size, figure_size* sqrt(3) / 2);
	glVertex3f(-figure_size * 0.5, scale* figure_size, figure_size* sqrt(3) / 2);
	glVertex3f(figure_size * 0.5, -scale * figure_size, figure_size* sqrt(3) / 2);

	glVertex3f(-figure_size * 0.5, scale* figure_size, figure_size* sqrt(3) / 2);
	glVertex3f(figure_size * 0.5, -scale * figure_size, figure_size* sqrt(3) / 2);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, figure_size* sqrt(3) / 2);

	glVertex3f(-figure_size * 0.5, scale* figure_size, figure_size* sqrt(3) / 2);
	glVertex3f(-figure_size, scale* figure_size, 0);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, figure_size* sqrt(3) / 2);

	glVertex3f(-figure_size, scale* figure_size, 0);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, figure_size* sqrt(3) / 2);
	glVertex3f(-figure_size, -scale * figure_size, 0);

	glVertex3f(-figure_size, scale* figure_size, 0);
	glVertex3f(-figure_size * 0.5, scale* figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(-figure_size, -scale * figure_size, 0);

	glVertex3f(-figure_size * 0.5, scale* figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(-figure_size, -scale * figure_size, 0);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);

	glVertex3f(-figure_size * 0.5, scale* figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(figure_size * 0.5, scale* figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);

	glVertex3f(figure_size * 0.5, scale* figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);

	glVertex3f(figure_size * 0.5, scale* figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(figure_size, scale* figure_size, 0);
	glVertex3f(figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);

	glVertex3f(figure_size, scale* figure_size, 0);
	glVertex3f(figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(figure_size, -scale * figure_size, 0);


	glVertex3f(figure_size, -scale * figure_size, 0);
	glVertex3f(figure_size * 0.5, -scale * figure_size, figure_size* sqrt(3) / 2);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, figure_size* sqrt(3) / 2);

	glVertex3f(figure_size, -scale * figure_size, 0);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, figure_size* sqrt(3) / 2);
	glVertex3f(-figure_size, -scale * figure_size, 0);

	glVertex3f(figure_size, -scale * figure_size, 0);
	glVertex3f(-figure_size, -scale * figure_size, 0);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);

	glVertex3f(figure_size, -scale * figure_size, 0);
	glVertex3f(-figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);
	glVertex3f(figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);

	glEnd();
	glPopMatrix();

	if (show_lines)
	{
		if (white)
		{
			glColor3f(0.2f, 0.2f, 0.2f);
		}
		else
		{
			glColor3f(0.8f, 0.8f, 0.8f);
		}
		glPushMatrix();
		glTranslatef(0.0, 0.0, 0.0);
		glRotatef(0.0, 0.0, 0.0, 0.0);
		glBegin(GL_LINES);

		glVertex3f(figure_size, scale * figure_size, 0);
		glVertex3f(figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);

		glVertex3f(figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);
		glVertex3f(-figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);

		glVertex3f(-figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);
		glVertex3f(-figure_size, scale * figure_size, 0);

		glVertex3f(-figure_size, scale * figure_size, 0);
		glVertex3f(-figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);

		glVertex3f(-figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);
		glVertex3f(figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);

		glVertex3f(figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);
		glVertex3f(figure_size, scale * figure_size, 0);


		glVertex3f(figure_size, scale * figure_size, 0);
		glVertex3f(figure_size, -scale * figure_size, 0);

		glVertex3f(figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);
		glVertex3f(figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);

		glVertex3f(-figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);
		glVertex3f(-figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);

		glVertex3f(-figure_size, scale * figure_size, 0);
		glVertex3f(-figure_size, -scale * figure_size, 0);

		glVertex3f(-figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);
		glVertex3f(-figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);

		glVertex3f(figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);
		glVertex3f(figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);


		glVertex3f(figure_size, -scale * figure_size, 0);
		glVertex3f(figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);

		glVertex3f(figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);
		glVertex3f(-figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);

		glVertex3f(-figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);
		glVertex3f(-figure_size, -scale * figure_size, 0);

		glVertex3f(-figure_size, -scale * figure_size, 0);
		glVertex3f(-figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);

		glVertex3f(-figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);
		glVertex3f(figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);

		glVertex3f(figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);
		glVertex3f(figure_size, -scale * figure_size, 0);

		glEnd();
		glPopMatrix();

		glPushMatrix();
		glTranslatef(0.0, 0.0, 0.0);
		glRotatef(90.0, 1.0, 0.0, 0.0);
		glBegin(GL_LINES);

		glVertex3f(figure_size, scale * figure_size, 0);
		glVertex3f(figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);

		glVertex3f(figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);
		glVertex3f(-figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);

		glVertex3f(-figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);
		glVertex3f(-figure_size, scale * figure_size, 0);

		glVertex3f(-figure_size, scale * figure_size, 0);
		glVertex3f(-figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);

		glVertex3f(-figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);
		glVertex3f(figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);

		glVertex3f(figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);
		glVertex3f(figure_size, scale * figure_size, 0);


		glVertex3f(figure_size, scale * figure_size, 0);
		glVertex3f(figure_size, -scale * figure_size, 0);

		glVertex3f(figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);
		glVertex3f(figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);

		glVertex3f(-figure_size * 0.5, scale * figure_size, figure_size * sqrt(3) / 2);
		glVertex3f(-figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);

		glVertex3f(-figure_size, scale * figure_size, 0);
		glVertex3f(-figure_size, -scale * figure_size, 0);

		glVertex3f(-figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);
		glVertex3f(-figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);

		glVertex3f(figure_size * 0.5, scale * figure_size, -figure_size * sqrt(3) / 2);
		glVertex3f(figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);


		glVertex3f(figure_size, -scale * figure_size, 0);
		glVertex3f(figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);

		glVertex3f(figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);
		glVertex3f(-figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);

		glVertex3f(-figure_size * 0.5, -scale * figure_size, figure_size * sqrt(3) / 2);
		glVertex3f(-figure_size, -scale * figure_size, 0);

		glVertex3f(-figure_size, -scale * figure_size, 0);
		glVertex3f(-figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);

		glVertex3f(-figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);
		glVertex3f(figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);

		glVertex3f(figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);
		glVertex3f(figure_size, -scale * figure_size, 0);

		glEnd();
		glPopMatrix();

		glPushMatrix();
		glTranslatef(0.0, 0.0, 0.0);
		glRotatef(90.0, 0.0, 0.0, 1.0);
		glBegin(GL_LINES);

		glVertex3f(figure_size, scale* figure_size, 0);
		glVertex3f(figure_size * 0.5, scale* figure_size, figure_size* sqrt(3) / 2);

		glVertex3f(figure_size * 0.5, scale* figure_size, figure_size* sqrt(3) / 2);
		glVertex3f(-figure_size * 0.5, scale* figure_size, figure_size* sqrt(3) / 2);

		glVertex3f(-figure_size * 0.5, scale* figure_size, figure_size* sqrt(3) / 2);
		glVertex3f(-figure_size, scale* figure_size, 0);

		glVertex3f(-figure_size, scale* figure_size, 0);
		glVertex3f(-figure_size * 0.5, scale* figure_size, -figure_size * sqrt(3) / 2);

		glVertex3f(-figure_size * 0.5, scale* figure_size, -figure_size * sqrt(3) / 2);
		glVertex3f(figure_size * 0.5, scale* figure_size, -figure_size * sqrt(3) / 2);

		glVertex3f(figure_size * 0.5, scale* figure_size, -figure_size * sqrt(3) / 2);
		glVertex3f(figure_size, scale* figure_size, 0);


		glVertex3f(figure_size, scale* figure_size, 0);
		glVertex3f(figure_size, -scale * figure_size, 0);

		glVertex3f(figure_size * 0.5, scale* figure_size, figure_size* sqrt(3) / 2);
		glVertex3f(figure_size * 0.5, -scale * figure_size, figure_size* sqrt(3) / 2);

		glVertex3f(-figure_size * 0.5, scale* figure_size, figure_size* sqrt(3) / 2);
		glVertex3f(-figure_size * 0.5, -scale * figure_size, figure_size* sqrt(3) / 2);

		glVertex3f(-figure_size, scale* figure_size, 0);
		glVertex3f(-figure_size, -scale * figure_size, 0);

		glVertex3f(-figure_size * 0.5, scale* figure_size, -figure_size * sqrt(3) / 2);
		glVertex3f(-figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);

		glVertex3f(figure_size * 0.5, scale* figure_size, -figure_size * sqrt(3) / 2);
		glVertex3f(figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);


		glVertex3f(figure_size, -scale * figure_size, 0);
		glVertex3f(figure_size * 0.5, -scale * figure_size, figure_size* sqrt(3) / 2);

		glVertex3f(figure_size * 0.5, -scale * figure_size, figure_size* sqrt(3) / 2);
		glVertex3f(-figure_size * 0.5, -scale * figure_size, figure_size* sqrt(3) / 2);

		glVertex3f(-figure_size * 0.5, -scale * figure_size, figure_size* sqrt(3) / 2);
		glVertex3f(-figure_size, -scale * figure_size, 0);

		glVertex3f(-figure_size, -scale * figure_size, 0);
		glVertex3f(-figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);

		glVertex3f(-figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);
		glVertex3f(figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);

		glVertex3f(figure_size * 0.5, -scale * figure_size, -figure_size * sqrt(3) / 2);
		glVertex3f(figure_size, -scale * figure_size, 0);

		glEnd();
		glPopMatrix();
	}
}

void draw_pawn(bool white, float figure_size)
{
	const double i = 0.5;// угол отклонения от высоты
	const double xi = 0.5;// угол отклонения от оси x
	short forvard = 0;
	if (white)
	{
		forvard = 1;
		glColor3f(0.8f, 0.8f, 0.8f);
	}
	else
	{
		forvard = -1;
		glColor3f(0.2f, 0.2f, 0.2f);
	}

	glPushMatrix();
	glTranslatef(0.0, 0.0, 0.0);
	glRotatef(0.0, 0.0, 0.0, 0.0);
	glBegin(GL_TRIANGLES);

	glVertex3f(0.0, 0.0, 0.0);
	glVertex3f(figure_size * cos(i) * forvard, figure_size * sin(i), 0);
	glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(-i) * sqrt(3) / 2);

	glVertex3f(0.0, 0.0, 0.0);
	glVertex3f(figure_size * cos(i) * forvard, figure_size * sin(i), 0);
	glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(i) * sqrt(3) / 2);

	glVertex3f(0.0, 0.0, 0.0);
	glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(-i) * sqrt(3) / 2);
	glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(i) * sqrt(3) / 2);

	glVertex3f(figure_size * cos(i) * forvard, figure_size * sin(i), 0);
	glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(-i) * sqrt(3) / 2);
	glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(i) * sqrt(3) / 2);

	glEnd();
	glPopMatrix();

	glPushMatrix();
	glTranslatef(0.0, 0.0, 0.0);
	glRotatef(120, 0.0, 0.0, 1.0);
	glBegin(GL_TRIANGLES);

	glVertex3f(0.0, 0.0, 0.0);
	glVertex3f(figure_size * cos(i) * forvard, figure_size * sin(i), 0);
	glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(-i) * sqrt(3) / 2);

	glVertex3f(0.0, 0.0, 0.0);
	glVertex3f(figure_size * cos(i) * forvard, figure_size * sin(i), 0);
	glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(i) * sqrt(3) / 2);

	glVertex3f(0.0, 0.0, 0.0);
	glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(-i) * sqrt(3) / 2);
	glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(i) * sqrt(3) / 2);

	glVertex3f(figure_size * cos(i) * forvard, figure_size * sin(i), 0);
	glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(-i) * sqrt(3) / 2);
	glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(i) * sqrt(3) / 2);

	glEnd();
	glPopMatrix();

	glPushMatrix();
	glTranslatef(0.0, 0.0, 0.0);
	glRotatef(210, xi, 0.0, 1.0);
	glBegin(GL_TRIANGLES);

	glVertex3f(0.0, 0.0, 0.0);
	glVertex3f(figure_size * cos(i) * forvard, figure_size * sin(i), 0);
	glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(-i) * sqrt(3) / 2);

	glVertex3f(0.0, 0.0, 0.0);
	glVertex3f(figure_size * cos(i) * forvard, figure_size * sin(i), 0);
	glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(i) * sqrt(3) / 2);

	glVertex3f(0.0, 0.0, 0.0);
	glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(-i) * sqrt(3) / 2);
	glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(i) * sqrt(3) / 2);

	glVertex3f(figure_size * cos(i) * forvard, figure_size * sin(i), 0);
	glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(-i) * sqrt(3) / 2);
	glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(i) * sqrt(3) / 2);

	glEnd();
	glPopMatrix();

	glPushMatrix();
	glTranslatef(0.0, 0.0, 0.0);
	glRotatef(210, -xi, 0.0, 1.0);
	glBegin(GL_TRIANGLES);

	glVertex3f(0.0, 0.0, 0.0);
	glVertex3f(figure_size * cos(i) * forvard, figure_size * sin(i), 0);
	glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(-i) * sqrt(3) / 2);

	glVertex3f(0.0, 0.0, 0.0);
	glVertex3f(figure_size * cos(i) * forvard, figure_size * sin(i), 0);
	glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(i) * sqrt(3) / 2);

	glVertex3f(0.0, 0.0, 0.0);
	glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(-i) * sqrt(3) / 2);
	glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(i) * sqrt(3) / 2);

	glVertex3f(figure_size * cos(i) * forvard, figure_size * sin(i), 0);
	glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(-i) * sqrt(3) / 2);
	glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(i) * sqrt(3) / 2);

	glEnd();
	glPopMatrix();

	if (show_lines)
	{
		if (white)
		{
			glColor3f(0.2f, 0.2f, 0.2f);
		}
		else
		{
			glColor3f(0.8f, 0.8f, 0.8f);
		}

		glPushMatrix();
		glTranslatef(0.0, 0.0, 0.0);
		glRotatef(0.0, 0.0, 0.0, 0.0);
		glBegin(GL_LINES);

		glVertex3f(0.0, 0.0, 0.0);
		glVertex3f(figure_size * cos(i) * forvard, figure_size * sin(i), 0);

		glVertex3f(0.0, 0.0, 0.0);
		glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(-i) * sqrt(3) / 2);

		glVertex3f(0.0, 0.0, 0.0);
		glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(i) * sqrt(3) / 2);

		glVertex3f(figure_size * cos(i) * forvard, figure_size * sin(i), 0);
		glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(-i) * sqrt(3) / 2);

		glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(-i) * sqrt(3) / 2);
		glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(i) * sqrt(3) / 2);

		glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(i) * sqrt(3) / 2);
		glVertex3f(figure_size * cos(i) * forvard, figure_size * sin(i), 0);

		glEnd();
		glPopMatrix();

		glPushMatrix();
		glTranslatef(0.0, 0.0, 0.0);
		glRotatef(120, 0.0, 0.0, 1.0);
		glBegin(GL_LINES);

		glVertex3f(0.0, 0.0, 0.0);
		glVertex3f(figure_size * cos(i) * forvard, figure_size * sin(i), 0);

		glVertex3f(0.0, 0.0, 0.0);
		glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(-i) * sqrt(3) / 2);

		glVertex3f(0.0, 0.0, 0.0);
		glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(i) * sqrt(3) / 2);

		glVertex3f(figure_size * cos(i) * forvard, figure_size * sin(i), 0);
		glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(-i) * sqrt(3) / 2);

		glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(-i) * sqrt(3) / 2);
		glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(i) * sqrt(3) / 2);

		glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(i) * sqrt(3) / 2);
		glVertex3f(figure_size * cos(i) * forvard, figure_size * sin(i), 0);

		glEnd();
		glPopMatrix();

		glPushMatrix();
		glTranslatef(0.0, 0.0, 0.0);
		glRotatef(210, xi, 0.0, 1.0);
		glBegin(GL_LINES);

		glVertex3f(0.0, 0.0, 0.0);
		glVertex3f(figure_size * cos(i) * forvard, figure_size * sin(i), 0);

		glVertex3f(0.0, 0.0, 0.0);
		glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(-i) * sqrt(3) / 2);

		glVertex3f(0.0, 0.0, 0.0);
		glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(i) * sqrt(3) / 2);

		glVertex3f(figure_size * cos(i) * forvard, figure_size * sin(i), 0);
		glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(-i) * sqrt(3) / 2);

		glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(-i) * sqrt(3) / 2);
		glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(i) * sqrt(3) / 2);

		glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(i) * sqrt(3) / 2);
		glVertex3f(figure_size * cos(i) * forvard, figure_size * sin(i), 0);

		glEnd();
		glPopMatrix();

		glPushMatrix();
		glTranslatef(0.0, 0.0, 0.0);
		glRotatef(210, -xi, 0.0, 1.0);
		glBegin(GL_LINES);

		glVertex3f(0.0, 0.0, 0.0);
		glVertex3f(figure_size * cos(i) * forvard, figure_size * sin(i), 0);

		glVertex3f(0.0, 0.0, 0.0);
		glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(-i) * sqrt(3) / 2);

		glVertex3f(0.0, 0.0, 0.0);
		glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(i) * sqrt(3) / 2);

		glVertex3f(figure_size * cos(i) * forvard, figure_size * sin(i), 0);
		glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(-i) * sqrt(3) / 2);

		glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(-i) * sqrt(3) / 2);
		glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(i) * sqrt(3) / 2);

		glVertex3f(figure_size * cos(-i) * forvard, figure_size * sin(-i) * 0.5, figure_size * sin(i) * sqrt(3) / 2);
		glVertex3f(figure_size * cos(i) * forvard, figure_size * sin(i), 0);

		glEnd();
		glPopMatrix();
	}
}

void draw_figure(int figure_type, float figure_size)
{
	switch(figure_type)
	{
	case WHITE_KING:
		draw_king(WHITE, figure_size);
		break;
	case WHITE_SUPER_QUIN:
		draw_super_quin(WHITE, figure_size);
		break;
	case WHITE_QUIN_DIAGONAL:
		draw_quin_diagonal(WHITE, figure_size);
		break;
	case WHITE_QUIN:
		draw_quin(WHITE, figure_size);
		break;
	case WHITE_BISHOP_DIAGONAL:
		draw_bishop_diagonal(WHITE, figure_size);
		break;
	case WHITE_BISHOP:
		draw_bishop(WHITE, figure_size);
		break;
	case WHITE_KNIGHT_DIAGONAL:
		draw_knight_diagonal(WHITE, figure_size);
		break;
	case WHITE_KNIGHT:
		draw_knight(WHITE, figure_size);
		break;
	case WHITE_ROOK:
		draw_rook(WHITE, figure_size);
		break;
	case WHITE_PAWN:
		draw_pawn(WHITE, figure_size);
		break;
	case BLACK_KING:
		draw_king(BLACK, figure_size);
		break;
	case BLACK_SUPER_QUIN:
		draw_super_quin(BLACK, figure_size);
		break;
	case BLACK_QUIN_DIAGONAL:
		draw_quin_diagonal(BLACK, figure_size);
		break;
	case BLACK_QUIN:
		draw_quin(BLACK, figure_size);
		break;
	case BLACK_BISHOP_DIAGONAL:
		draw_bishop_diagonal(BLACK, figure_size);
		break;
	case BLACK_BISHOP:
		draw_bishop(BLACK, figure_size);
		break;
	case BLACK_KNIGHT_DIAGONAL:
		draw_knight_diagonal(BLACK, figure_size);
		break;
	case BLACK_KNIGHT:
		draw_king(BLACK, figure_size);
		break;
	case BLACK_ROOK:
		draw_rook(BLACK, figure_size);
		break;
	case BLACK_PAWN:
		draw_pawn(BLACK, figure_size);
		break;
	}
}

void draw_all_figures(float distance)
{
	glPushMatrix();
	glTranslatef(1000.0f, 1000.0f, 1000.0f);
	draw_cube();
	glPopMatrix();

	for (int x_pos = 0; x_pos < 8; x_pos++)
	{
		for (int y_pos = 0; y_pos < 8; y_pos++)
		{
			for (int z_pos = 0; z_pos < 8; z_pos++)
			{
				switch (gamespase1->GetPoint(x_pos + y_pos * list->GetElement(0) + z_pos * list->GetElement(0) * list->GetElement(1)))
				{
				case WHITE_ROOK:
					glPushMatrix();
					glTranslatef(x_pos * distance, y_pos * distance, z_pos * distance);
					draw_rook(WHITE, 0.25f);
					glPopMatrix();
					break;
				case WHITE_PAWN:
					glPushMatrix();
					glTranslatef(x_pos * distance, y_pos * distance, z_pos * distance);
					draw_pawn(WHITE, 1.0f);
					glPopMatrix();
					break;
				case BLACK_ROOK:
					glPushMatrix();
					glTranslatef(x_pos * distance, y_pos * distance, z_pos * distance);
					draw_rook(BLACK, 0.25f);
					glPopMatrix();
					break;
				case BLACK_PAWN:
					glPushMatrix();
					glTranslatef(x_pos * distance, y_pos * distance, z_pos * distance);
					draw_pawn(BLACK, 1.0f);
					glPopMatrix();
					break;
				default:
					if (gamespase1->GetPoint(x_pos + y_pos * list->GetElement(0) + z_pos * list->GetElement(0) * list->GetElement(1)) > 0)
					{
						glColor3f(0.8f, 0.8f, 0.8f);
						glPushMatrix();
						glTranslatef(x_pos * distance, y_pos * distance, z_pos * distance);
						draw_cube();
						glPopMatrix();
					}
					else if (gamespase1->GetPoint(x_pos + y_pos * list->GetElement(0) + z_pos * list->GetElement(0) * list->GetElement(1)) < 0)
					{
						glColor3f(0.2f, 0.2f, 0.2f);
						glPushMatrix();
						glTranslatef(x_pos * distance, y_pos * distance, z_pos * distance);
						draw_cube();
						glPopMatrix();
					}
					break;
				}
			}
		}
	}
}


void draw_poligon()
{
	glColor3f(0.2f, 0.9f, 0.2f);//Установка цвета фигуры.

	glBegin(GL_TRIANGLES); // полигон с коондинатами
	glVertex3f(-100.0f, -4.0f, -100.0f);
	glVertex3f(-100.0f, -4.0f, 100.0f);
	glVertex3f(100.0f, -4.0f, 100.0f);

	glVertex3f(-100.0f, -4.0f, -100.0f);
	glVertex3f(100.0f, -4.0f, -100.0f);
	glVertex3f(100.0f, -4.0f, 100.0f);
}

void recalculate_camera()
{
	angle_xy += d_angle_xy;
	angle_xz += d_angle_xz;
	lx = sin(angle_xz) * cos(angle_xy);
	ly = sin(angle_xy);
	lz = -cos(angle_xz) * cos(angle_xy);
	y += camera_speed * move_y;
	if (forvard_backvard)
	{
		x += sin(angle_xz) * camera_speed * move_x;
		z += -cos(angle_xz) * camera_speed * move_z;
	}
	else
	{
		x += cos(angle_xz) * camera_speed * move_x;
		z += -sin(angle_xz) * camera_speed * move_z;
	}

}

void render_camera()
{
	recalculate_camera();
	gluLookAt(x, y, z,
		x + lx, y + ly, z + lz,
		0.0f, 1.0f, 0.0f);// установка камеры
}

void render_Scene()
{

	test_angle += 0.5;

	glClearColor(0.4, 0.4, 1.0, 1.0);// цвет фонa

	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	glEnable(GL_DEPTH_TEST);

	glLoadIdentity();// обнуление трансформации

	render_camera();

	draw_all_figures(5.0);

	glutSwapBuffers();
	if (!mouse_motion)
	{
		d_angle_xy = 0;
		d_angle_xz = 0;
	}
	mouse_motion = false;
}

void changeSize(int window_wight, int window_hight)
{

	// предупредим деление на ноль
	// если окно сильно перетянуто будет
	if (window_hight == 0)
	{
		window_hight = 1;
	}

	float ratio = 1.0 * window_wight / window_hight;

	// используем матрицу проекции
	glMatrixMode(GL_PROJECTION);

	// Reset матрицы
	glLoadIdentity();

	// определяем окно просмотра
	glViewport(0, 0, window_wight, window_hight);

	// установить корректную перспективу.
	gluPerspective(60, ratio, 1, 1000);

	// вернуться к модели
	glMatrixMode(GL_MODELVIEW);
}

void press_special_key(int key, int mouse_x_position, int mouse_y_position)
{
}

void press_up_special_key(int key, int mouse_x_position, int mouse_y_position)
{
	glutSetKeyRepeat(GLUT_KEY_REPEAT_DEFAULT);
}

void press_normal_key(unsigned char key, int mouse_x_position, int mouse_y_position)
{
	glutSetKeyRepeat(GLUT_KEY_REPEAT_OFF);
	switch (key)
	{
	case 'a':
		forvard_backvard = false;
		move_x = -1;
		move_z = 1;
		break;
	case 'd':
		forvard_backvard = false;
		move_x = 1;
		move_z = -1;
		break;
	case 'e':
		move_y = 1;
		break;
	case 'l':
		if (show_lines)
		{
			show_lines = false;
		}
		else
		{
			show_lines = true;
		}
		break;
	case 'q':
		move_y = -1;
		break;
	case 's':
		forvard_backvard = true;
		move_x = -1;
		move_z = -1;
		break;
	case 'w':
		forvard_backvard = true;
		move_x = 1;
		move_z = 1;
		break;
	case 'x':
		std::cout << "x = " << x << '	' << "y = " << y << '	' << "z = " << z << std::endl
			<< "angle_xz = " << angle_xz << '	' << "angle_xy = " << angle_xy << std::endl
			<< "test_angle = " << test_angle << std::endl;
		break;
	case 27:
		exit(0);
		break;
	}
}

void press_up_normal_key(unsigned char key, int mouse_x_position, int mouse_y_position)
{
	switch (key)
	{
	case 'a':
	case 'd':
		move_x = 0;
		move_z = 0;
		break;
	case 'e':
	case 'q':
		move_y = 0;
		break;
	case 's':
	case 'w':
		move_x = 0;
		move_z = 0;
		break;
	}
	glutSetKeyRepeat(GLUT_KEY_REPEAT_DEFAULT);
}

void mouse_func(int button, int buttom_state, int mouse_x_position, int mouse_y_position)
{
	if (buttom_state == GLUT_DOWN)
	{
		switch (button)
		{
		case GLUT_LEFT_BUTTON:
			break;
		case GLUT_RIGHT_BUTTON:
			bottoms[2] = true;
			mouse_x_position_last = mouse_x_position;
			mouse_y_position_last = mouse_y_position;
			break;
		}
	}
	if (buttom_state == GLUT_UP)
	{
		switch (button)
		{
		case GLUT_RIGHT_BUTTON:
			bottoms[2] = false;
			mouse_x_position_last = NULL;
			mouse_y_position_last = NULL;
			d_angle_xz = 0;
			d_angle_xy = 0;
			break;
		}
	}
}

void motion_func(int mouse_x_position, int mouse_y_position)
{
	mouse_motion = true;
	if (bottoms[2])
	{
		d_angle_xz = (mouse_x_position - mouse_x_position_last) * mouse_modification;
		d_angle_xy = (-mouse_y_position + mouse_y_position_last) * mouse_modification;
		mouse_x_position_last = mouse_x_position;
		mouse_y_position_last = mouse_y_position;
	}
}

void motion_passive_func(int mouse_x_position, int mouse_y_position)
{

}

int main(int argc, char** argv)//* int argc - количество аргументов | char** argv - их описание в виде указателя на строку
{
	glEnable(GL_DEPTH);

	glutInit(&argc, argv);
	glutInitWindowPosition(400, 100);
	glutInitWindowSize(window_wight, window_hight);
	glutInitDisplayMode(GLUT_DEPTH | GLUT_DOUBLE | GLUT_RGBA);
	glutCreateWindow("Chess3D");

	glPushMatrix();
	glTranslatef(1.0f, 1.0f, 1.0f);
	glPopMatrix();

	glutDisplayFunc(render_Scene);

	glutReshapeFunc(changeSize);// регистрирует для GLUT функцию обратного вызова

	glutIdleFunc(render_Scene);// регистрирует функцию обратного вызова, которая будет вызываться когда само приложение находится в режиме ожидания

	glutKeyboardFunc(press_normal_key);
	glutKeyboardUpFunc(press_up_normal_key);
	glutSpecialFunc(press_special_key);
	glutSpecialUpFunc(press_up_special_key);// клавиатура

	glutMouseFunc(mouse_func);
	glutMotionFunc(motion_func);
	glutPassiveMotionFunc(motion_passive_func);// мышь

	glutMainLoop();

	glutSetKeyRepeat(GLUT_KEY_REPEAT_DEFAULT);
}
